<!DOCTYPE html>
<html lang = "en">
   <head>
	  <meta charset="UTF-8">
	  <link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet">
	  <script type="text/javascript" src="https://d3js.org/d3.v5.min.js"></script>
	  <script type="text/javascript" src="labeler.js"></script>
	  <style>
	  	
	  	.body {
	  		font-family: 'Open Sans', sans-serif;
	  	}

	  	.select-container {
	  	}
	  	.select-description {
	  		font-family: 'Open Sans', sans-serif;
	  		white-space: nowrap;
	  		margin-bottom: 0%;
	  	}

	  	.income-option {
	  		font-family: 'Open Sans', sans-serif;
	  		font-size: 15px;
	  	}

	  	.line {
		  fill: none;
		  stroke: none;
		}

		.area {
	  		fill: black;
	  	}

	  	.label {
	  		font-size: 15px;
	  		font-family: 'Open Sans', sans-serif;
	  	}

	  	.leader-line {
	  		stroke-width: 0.5;
	  		stroke-dasharray: 2,2;
	  	}

	  </style>
	</head>

	<body>
		<div class="graph-container"></div>

		<script type="text/javascript">

			// country metadata
			var metaData = {"country": {"region": "", "income": "", "lastPopulation": ""},}

			// svg sizing
			var margin = {top: 20, right: 200, bottom: 30, left: 50},
				width = 1060 - margin.left - margin.right,
				height = 880 - margin.top - margin.bottom;

			// label displacement
			var labelDis = 20; // distance between line end and label

			// formating functions
			var parseDate = d3.timeParse("%Y");

			// helper functions
			function findMinMax(arr, key) {
				// find minimum and maximum value in array
				let min = arr[0][key], max = arr[0][key];

				for (let i = 1, len=arr.length; i < len; i++) {
					let v = arr[i][key];
					min = (v < min) ? v : min;
					max = (v > max) ? v : max;
				}
				return [min, max];
			}

			function convertString(string) {
				// convert string to be usable as ID/class
				return string.replace(/[^a-zA-Z]/g, "");
			}

			// append the svg obgect to the body of the page
			var svg = d3.select(".graph-container").append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			// import data and populate svg
			Promise.all([
				d3.csv("pop_total.csv"),
				d3.csv("metadata.csv"),
			]).then(function(files) {

				// assign files
				var data = files[0],
					metaData = files[1];

				// get column headers
				var countries = d3.keys(data[0]);
				countries.shift();

				// remove all entries with _ (denoting upper/lower limits)
				for (var i = countries.length - 1; i >= 0; i--) {
						if (countries[i].indexOf("_") > -1)  { 
							countries.splice(i, 1);  
						} 
					};
				
				// format data
				data.forEach(function(d) {
					d['Year'] = parseDate(d['Year']);

					countries.forEach(function(c) {
						d[c] = parseFloat(d[c])
					})
				});

				// get min/max percentage changes
				var minMaxChanges = [];

				countries.forEach(function(c) {
					var lims = findMinMax(data, c)
					minMaxChanges.push(lims)
				})

				var maxChange = Math.max(...[].concat(...minMaxChanges));
				var minChange = Math.min(...[].concat(...minMaxChanges));

				// get unique metadata values
				var incomeGroups = metaData.map(x => x.IncomeGroup)
					.filter((value, index, self) => self.indexOf(value) === index);

				var regions = metaData.map(x => x.Region)
					.filter((value, index, self) => self.indexOf(value) === index).sort();

				// add foreign object container
				var foreignObject = svg.append('foreignObject')
					.attr("width", 1)
					.attr("height", 1)
					.attr("x", width/10)
					.attr("y", height/10)
					.attr("overflow", "visible")

				// selector container
				var selectContainer = foreignObject.append("xhtml:div")
					.attr("class", "select-container")

				// selector description
				selectContainer.append("xhtml:p")
					.html("Select Income Group:")
					.attr("class", "select-description");

				// selector
				selectContainer.append("select")
					.attr("id", "selectIncomeButton");

				// add all income groups selection
				d3.select("#selectIncomeButton")
					.append("option")
						.attr("class", "income-option")
						.text("None")
						.attr("value", "None");

				// add income group options to dropdown
				d3.select("#selectIncomeButton")
					.selectAll()
					.data(incomeGroups)
					.enter()
    					.append("option")
    					.attr("class", "income-option")
      					.text(function (d) { return d; }) // text shon in dropdown
      					.attr("value", function (d) { return d; }) // value returned by selection

				// set data ranges and scales
		 		var xscale = d3.scaleTime()
		 			.domain(d3.extent(data, function(d) { return d['Year']; })) 
					.range([0, width]);

				var yscale = d3.scaleLinear()
					.domain([minChange, maxChange])
					.range([height, 0]);
				
				for (var i = 0; i < countries.length; i++) {
					
					// replace special characters in country name for id usage
					var countryID = convertString(countries[i]);

					// find income group & region
					var incomeGroup = convertString(metaData.find(x => x.Country === countries[i]).IncomeGroup),
						region = convertString(metaData.find(x => x.Country === countries[i]).Region);

					// group that holds country components
					var countryGroup = svg.append("g")
						.attr("class", "country-group " + incomeGroup)
						.attr("id", countryID)
						.attr("data-country", countries[i]);

					// plot lower and upper limit line for each country
					var lineMid = d3.line()
						.x(function(d) { return xscale(d['Year']); })
						.y(function(d) { return yscale(d[countries[i]]); });

					var lineLow = d3.line()
						.x(function(d) { return xscale(d['Year']); })
						.y(function(d) { return yscale(d[countries[i] + '_low']); });

					var lineUp = d3.line()
						.x(function(d) { return xscale(d['Year']); })
						.y(function(d) { return yscale(d[countries[i] + '_up']); });

					countryGroup.append("path")
						.datum(data)
						.attr("class", "line")
						.attr("id", countryID + "_mid")
						.attr("d", lineMid);

					countryGroup.append("path")
						.datum(data)
						.attr("class", "line")
						.attr("id", countryID + "_low")
						.attr("d", lineLow);

					countryGroup.append("path")
						.datum(data)
						.attr("class", "line")
						.attr("id", countryID + "_up")
						.attr("d", lineUp);

					// fill area between lines
					var area = d3.area()
						.x(function(d) { return xscale(d['Year']); })
						.y0(function(d) { return yscale(d[countries[i] + '_low']); })
						.y1(function(d) { return yscale(d[countries[i] + '_up']); });

					countryGroup.append("path")
						.datum(data)
						.attr("class", "area " + incomeGroup)
						.attr("d", area)
						.attr("id", countryID + "_area")
						.attr("opacity", 0.2)
						.on("mouseover", 
							function() {
								// only act on mouseover if line is not affected by selector
								if (d3.select(this).classed("selected") === false) {
									// highlight area on hover
									d3.select(this)
										.transition().duration(200)
											.attr("opacity", 0.7);

									// hide labels from income selection
									d3.selectAll(".label")
										.transition().duration(200)
											.attr("fill", "none");

									// hide leader lines
									d3.selectAll(".leader-line")
										.transition().duration(200)
											.attr("fill", "none")
											.attr("stroke", "none");

									// add line label
									var country = d3.select(this.parentNode).attr("data-country"),
										countryID = convertString(country),
										xPosLabel = d3.select("#" + countryID + "_mid").node().getBBox().width + labelDis,
										lineLen = d3.select("#" + countryID + "_mid").node().getTotalLength(),
										yPosLabel = d3.select("#" + countryID + "_mid").node().getPointAtLength(lineLen).y;

									var label = d3.select(this.parentNode)
										.append("text")
										.attr("class", "label")
										.attr("id", countryID + "_label")
										.text(country)
										.attr("x", xPosLabel)
										.attr("y", yPosLabel)
										.attr("alignment-baseline", "middle")
									
									label.transition().duration(200)
										.attr("fill", "black");
								}
							})
						.on("mouseout",
							function() {
								// only act on mouseover if line is not affected by selector
								if (d3.select(this).classed("selected") === false) {
									// reduce line opacity
									d3.select(this)
										.transition().duration(200)
											.attr("opacity", 0.2);

									// remove line label
									var labelID = d3.select(this).attr("id").split("_")[0] + "_label";
									d3.selectAll("#" + labelID)
											.remove();

									// show hidden labels again
									d3.selectAll(".label")
										.transition().duration(200)
										.attr("fill", "black");

									// show hidden leader lines again
									d3.selectAll(".leader-line")
										.transition().duration(200)
											.attr("fill", "black")
											.attr("stroke", "black");
								}
						});
					};

				// add x- and y-axis
				svg.append("g")
					.attr("transform", "translate(0, " + height + ")")
					.call(d3.axisBottom()
						.scale(xscale))

				 svg.append("g")
					.call(d3.axisLeft()
						.scale(yscale))

				// highlight selected group
				function highlightGroup(selectedGroup) {

					// label optimizer arrays
					var labelArr = [],
						anchorArr = [];

					// unselect all countries
					d3.selectAll(".area")
						.classed("selected", false)
						.transition().duration(200)
							.attr("opacity", 0.2);

					// remove labels
					d3.selectAll(".label")
						.attr("fill", "none")
						.remove();

					// remove leader lines
					d3.selectAll(".leader-line")
						.attr("fill", "none")
						.remove();

					// highlight selected group
					d3.selectAll(".area").filter("." + selectedGroup)
						.classed("selected", true)
						.transition().duration(200)
							.attr("opacity", 0.7);

					// collect label data & add label elements
					d3.selectAll(".country-group" + "." + selectedGroup)
						.each(function(d) {
							var country = d3.select(this).attr("data-country"),
								countryID = convertString(country),
								xPosLabel = d3.select(this).select("#" + countryID + "_mid").node().getBBox().width + labelDis,
								lineLen = d3.select(this).select("#" + countryID + "_mid").node().getTotalLength(),
								yPosLabel = d3.select(this).select("#" + countryID + "_mid").node().getPointAtLength(lineLen).y;

							labelArr.push({x: xPosLabel, y: yPosLabel, name: country, width: 0.0, height: 0.0, incomeGroup: incomeGroup});
							anchorArr.push({x: xPosLabel, y: yPosLabel,r: 0.0});

							d3.select(this)
								.append("text")
								.attr("class", "label")
						});

					// draw labels
					labels = d3.selectAll(".label")
						.data(labelArr)
						.attr('text-anchor', 'start')
						.text(function(d) { return d.name; })
						.attr("x", function(d) { return (d.x); })
						.attr("y", function(d) { return (d.y); })
						.attr("alignment-baseline", "middle")
						.attr("fill", "none");

					// get label sizes
					var i = 0;
					labels.each(function() {
						labelArr[i].width = d3.select(this).node().getBBox().width;
						labelArr[i].height = d3.select(this).node().getBBox().height;
						i += 1;
					})

					// optimize label placement
					d3.labeler()
						.label(labelArr)
						.anchor(anchorArr)
						.width(width)
						.height(height)
						.start(2000);

					// redraw labels
					labels
						.attr("x", function(d) { return (d.x); })
						.attr("y", function(d) { return (d.y); })
						.transition().duration(200)
							.attr("fill", "black");

					// add leader lines
					var leadLines = [];
					for (var i=0; i < labelArr.length; i++) {
						leadLines.push([{x: labelArr[i].x, y: labelArr[i].y}, {x: anchorArr[i].x - labelDis, y: anchorArr[i].y}]);
					}

					var leadLine = d3.line()
						.x(function (d) { return d.x; })
						.y(function (d) { return d.y; });

					for (var i=0; i < leadLines.length; i++) {
						svg.append("path")
						.attr("class", "leader-line")
						.datum(leadLines[i])
						.attr("d", leadLine)
						.attr("fill", "black")
						.attr("stroke", "black");
					}

				};

				// add action to changing selection
				d3.select("#selectIncomeButton")
					.on("change", function(d) {
						// get selected value from dropdown
						var selectedGroup = convertString(d3.select(this).property("value"));
						
						// highlight based on selection
						highlightGroup(selectedGroup);
					});
			});


		</script>


	</body>